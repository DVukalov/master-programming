---
title: Master programming
subtitle: Лекция №1 (Обзор курса)
author: Игорь Шаронов
date: 2018-01-15
---

## Из чего состоит курс {#review}

* Операционная система
* Редактор
* Система сборки
* Отладка
* Тестирование
* Система контроля версий
* Программирование на C++
* Документация
* Разработка в команде
* *Домашняя лабораторная работа*

# Операционная система {#os}

## Из чего состоит операционная система {#os-consists}

* Планировщик задач
* Распределение памяти
* Изоляция (страничная адресация)
* Ресурсы

## Объекты ядра ОС {#os-objects}

* Процессы, потоки
* Файлы, каналы (pipes)
* Семафоры, мьютексы
* Проекции в память (mmap)

---

## Linux {#linux}

* Основан на Unix
* Только ядро и компилятор
* Linux $\neq$ Unix
* Virtual File System (VFS) --- представление всех объектов в виде файлов

```sh
$ ls /
bin  boot  dev  etc  home include lib  lib64 proc  root  run  sys  tmp  usr  var
```

## Жизнь в консоли {#life-in-console}

* GNU Coreutils
    * текстовые утилиты: sort, tr, tail, cat, wc, uniq, ...
    * файловые утилиты: ls, cp, dd, chmod, ln, mv, rm, ...
    * скриптовые утилиты: basename, echo, pwd, tee, ...
* GNU Binutils
    * as, ld, ar, objcopy, strip, gprof, ...
    * nm, objdump, readelf, strings, addr2line, c++filt, ...
* GNU Debugger
* Базовые утилиты: grep, sed  (1974 г.), awk (1977 г.), bash, perl, python

## Linux в использовании {#linux-usage}

* xorg-server, протокол X11
* window-manager: оконный, тайловый
* демоны (daemons)
* драйверы:
    * обычные файлы, которые умеют обрабатывать вызов `ioctl`
    * находятся в папке `/dev/`
    * и в `/sys/class/`
    * работают в режиме ядра
* драйверы в режиме пользователя: fuse, cuse, uio

---

## Редактор {#editor}

* ed (1971 г.)
* sed, vi, vim, neovim
* emacs
* sublime
* notepad++
* gedit
* IDE $\neq$ Editor

## Процесс редактирования {#editing}

1. Перемещение по тексту, поиск, скроллинг (view-mode)
1. Разделение области просмотра/редактирования
1. Подсветка синтаксиса
1. Редактирование, замена, удаление, вставка
1. Поиск-замена
1. Поддержка пользовательских плагинов
1. *Использование уже готового функционала сторонних программ*

## Пример: Vim {#vim}

* 3 режима: normal, insert (replace), visual
* Программируемая панель
* Буферы, табы, окна
* Большое многообразие плагинов (VimL)
* Подсветка синтаксиса, цветовая схема --- тоже плагин
* Орфография
* Использование ctag для перехода по функциям (любого языка, даже $\LaTeX$)
    * Отображение дерева функций

## Пример: Vim (продолжение) {#vim-continue}

* Автодополнение (несколько видов)
* Запуск интерактивной оболочки вместо буфера
* Встраиваемое GUI
* Возможность использования без GUI
* **Холивары: neovim**

---

## Системы сборки {#build-system}

* make (1977 г., Bell Labs)
* ninja
* scons
* meson
* cmake
* ~~свой велосипед~~ НЕТ!

## Makefile {#makefile}

```makefile
SRC := $(wildcard src/*.cpp)
HDR := $(wildcard include/*.h)
OBJ := $(patsubst src/%.cpp,build/%.o,$(SRC))

%.o: %.cpp
»»»»@g++ -c $< -o $@

lib.a: $(OBJ)
»»»»@ar -c $@ $^

app: main.cpp lib.a
»»»»g++ $^ -o $@

all: app

clean:
»»»»@rm -f $(OBJ) app *.a
```

## CMake {#cmake}

* Шаг конфигурации (аналогичен старому подходу `./configure`)
* Сборка привычными инструментами (`make`, `ninja`, `MSBuild`, ...)
* Запуск тестов через `ctest`
* Пакетирование через `cpack` (tar.gz, deb, rpm, zip, ...)
* Тьюринг-полный скриптовый язык
* Абстрагирование от операционной системы

---

# Отладка программ {#debugging}

* gdb
* nm, readelf, objdump
* valgrind
* gprof
* логирование

---

# Тестирование {#testing}

* TDD, BDD --- способы написания программы
* Юнит-тестирование → интеграционное тестирование → продакшен-тестирование
* Статистика, бенчмарки
* Fixture, test suite, mock, stub, ...
* Тестовые данные: генерация на месте, хранение в репозитории или брать удалённо с сервера?
* Границы между разными формами тестирования

---

## Системы контроля версий {#vcs}

* Version Control System (VCS)
* cvs
* subversion (svn)
* git
* mercurial (hg)
* ~~лучше я в архивах, по старинке~~ НЕТ!
* необходимо учитывать версионность продукта

## Основные понятия VCS {#vcs-basic}

<div class='column' style='float:left'>
* изменения
* коммит: изменения + сообщение + автор
* ветка разработки
* слияние (merge)
* конфликты слияния
* pull, checkout, fetch, push
</div>

<div class='column'>![](http://nvie.com/img/centr-decentr@2x.png)</div>

---

# Программирование на C++ {#cxx-programming}

* Новый стандарт лучше старого?
* ~~Лучше на C писать: понятнее и проще~~
* Соблюдение стиля кода
* ~~Иксепшены --- это зло!~~ Но надо быть аккуратнее
* Концепции стабильного кода vs. понятный код
* Разработка по спирали

---

# Документация {#documentation}

* Зачем нужна документация, если её никто не читает?
* Пример документации --- <http://libfuse.github.io/doxygen>
* Doxygen
* Написание презентаций, статей и книг
* $\LaTeX$, groff, docx, reStructuredText, HTML, AsciiDoc, DocBook, markdown --- в чём писать документацию?
* Генерация linux-документации `man`

---

# Разработка в команде {#team-development}

* Что такое команда и зачем она нужна?
* Распределение ролей в команде?
* Зачем нужен тот чувак, который ничего не делает?
* Стендапы, планнинги, грумминги, ретроспективы --- зачем они нужны?
* Deadline, sprint, milestone, release, post-mortem --- а это зачем?
* CTO, CEO, ~~IPO~~, PM, PO --- это что за клоуны?
* <span style="color:red">Agile</span> --- выход из всех проблем
* Психология разработки

---

# Бесплатные ссылки {#free-links}

Бесплатные книжки про программирование в целом:

<https://github.com/EbookFoundation/free-programming-books>

---

## Лабораторная работа {#lab-work}

1. Цель работы: написать драйвер устройства
    - процессор общего назначения, понимающий некоторый ассемлер
    - процессор компенсации движения в видео
1. Завести аккаунт на [github](https://github.com)
1. Настроить виртуальную машину с linux (libvirt)
1. Почитать документацию `libfuse`

## {#common-processor}
### Драйвер процессора общего назначения

Примерная структура драйвера
```
/dev/
└── mycpu/
    ├── unit0
    │   ├── pram
    │   └── lram
    ├── unit1
    │   ├── pram
    │   └── lram
    ...
    ├── unitn
    │   ├── pram
    │   └── lram
    └── ctrl
```

## {#video-processor}
### Драйвер процессора компесации движения

Примерная структура драйвера
```
/dev/
└── mycpu/
    ├── unit0
    │   ├── vrom
    │   └── vram
    ├── unit1
    │   ├── vrom
    │   └── vram
    ...
    ├── unitn
    │   ├── vrom
    │   └── vram
    └── ctrl
```

## Требования {#requirements}

1. Использовать `fuse` версии 3.2+
1. Система сборки --- `cmake`
1. Тестирование через `ctest`
1. Генерация документации `doxygen`-ом по цели `make install`
1. <span style="color:gray">Проверка стиля кода<span>
1. Упаковка установочного пакета: deb, tar.gz
1. Скрипты для проверки (интеграционное тестирование)
